% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/SOptim_RandSearchAlgorithm.R
\name{randomSearchOptim}
\alias{randomSearchOptim}
\title{Perform random search optimization}
\usage{
randomSearchOptim(
  fitFunc,
  paramList,
  numIter = 250,
  nneigh = 5,
  initNeighs = (5 * nneigh),
  neighSizeProp = 0.025,
  iter = 25,
  maximize = TRUE,
  parallel = FALSE,
  seed = NULL,
  verbose = TRUE,
  ...
)
}
\arguments{
\item{fitFunc}{A fitness/objective function object to iterate (the first input of 
this function must be a vector of parameters to be tested (named \code{x}), following 
the order of elements in a parameter list).}

\item{paramList}{An input list containing the parameter ranges}

\item{numIter}{Number of iterations used to run the algorithm (default: 250).}

\item{nneigh}{Number of neighbors (or parameter combinations) to generate in the vicinity 
of the best (default: 5).}

\item{initNeighs}{Number of parameter combinations to randomly draw from paramList at initialization 
(default: 5 * nneigh)}

\item{neighSizeProp}{Size of the neighbourhood for a given parameter, i.e., a real value contained 
in ]0, 1] used to multiply the range size as: \eqn{neighSize = (max_{range} - min_{range}) \times neighSizeProp}.}

\item{iter}{Number of sucessive iterations used to stop the algorithm if no improvement is found 
(default: 25).}

\item{maximize}{Should the value of the fitness function be optimized? (default: TRUE)}

\item{parallel}{Use a paralell backend? Use an integer value to define the number of 
instances to use (default: FALSE). Uses \link[GA]{startParallel} to initiate the parallel backend.}

\item{seed}{Set seed value? Integer value (default: NULL).}

\item{verbose}{Print output messages? This will be passed along to other functions 
as well (default: TRUE).}

\item{...}{Additional parameters passed to the fitness function.}
}
\value{
A list object of size two containing:        
\itemize{
   \item bestFitValue - The value of fitness function for the best solution
   \item bestParams - Parameters used to generate the best solution 
}
}
\description{
A simple function to perform iterative random search optimization using neighborhood 
fixed size adjustment. See details section for a description of the algorithm.
}
\details{
The algorithm proceeds as follow (for maximization):         

\preformatted{           

for i in 1:numIter\{        
        
  if i=1 then start\{           
    
    Randomly draw n = initNeighs parameter combinations bounded by paramList:       
      randParamGrid <- drawRandom(paramList)
      
    Run the fitness/objective function: 
      fitValues <- fitFunc(randParamGrid)
    
    Set the best output of the fitness function: 
      bestFitValue <- fitValues[bestIdx]               
    
    Set the best parameter combination: 
      bestParam <- randParamGrid[bestIdx, ]         
    
    Adjust parameter ranges to the neighbourhood of bestParam: 
      bestParamList <- adjustParamRangesNeigh(bestParam, neighSizeProp)    
    
    Set the stopping counter variable: 
      stopCounter <- 0         
  \}
            
  if i > 1\{
    
    Randomly draw n = nneigh parameter combinations bounded by bestParamList:
      randParamGrid <- drawRandom(bestParamList)   
    
    Run the fitness/objective function: 
      fitValues <- fitFunc(randParamGrid)
    
    Set the best output of the fitness function for iteration i: 
      bestFitValue_i <- fitValues[bestIdx]         
                      
    Check if fitness value improved and update them in that case: 
      if(bestFitValue_i > bestFitValue)\{                 
                     
      Set new best fit value: 
        bestFitValue <- bestFitValue_i        
      
      Set new best parameter combination: 
        bestParam <- randParamGrid[bestIdx, ]         
      
      Adjust parameter ranges: 
        bestParamList <- adjustParamRangesNeigh(bestParam, neighSizeProp)          
      
      Reset the stopping counter on update: 
        stopCounter <- 0           
      
    \}else\{        
      Update the stop counter variable: 
        stopCounter <- stopCounter + 1          
    \}      
   
    if(stopCounter >= iter)\{
       return(bestFitValue, bestParamList)             
    \}                       
  \}                   
\}
} 
            
  
The neighbourhood range vector of the best set of parameters for a given iteration is defined as:  
                    
\eqn{neighRange = [min_{range}(bestParam) - neighSize; max_{range}(bestParam) + neighSize;] }
where,                 
\eqn{neighSize = (max_{range}(bestParam) - min_{range}(bestParam)) \times neighSizeProp}

If any parameter in neighRange is outside the initial ranges then it is ajusted for these values.
}
\examples{

fitFunc <- function(x) return(cos(3*pi*x) / x)
 
bestFit <- randomSearchOptim(fitFunc, paramList=list(x=c(0, 1)), numIter=500, nneigh = 5, 
                  neighSizeProp = 0.01, maximize = FALSE, iter = 50, 
                 parallel = FALSE, seed=NULL, verbose = TRUE)

}
